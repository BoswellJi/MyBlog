import{_ as a,c as n,b as e,o as p}from"./app-B56A7WC8.js";const t={};function l(i,s){return p(),n("div",null,s[0]||(s[0]=[e(`<p>我早期学习设计模式的经验中，我自己发现下面的表格，它提醒许多模式必须提供什么。它包含了Gof提到的23种设计模式。原始的表格是Elyse Nielsen在2004年下半年总结的，我已经在必要的地方修改过它，来适合我们在本书这一部分的讨论。</p><p>我推荐实用这个表格作为参考，但是记着，还有许多额外的模式在这里没有提到，但是会在这本书的后面会讨论。</p><h2 id="关于类的简短笔记" tabindex="-1"><a class="header-anchor" href="#关于类的简短笔记"><span>关于类的简短笔记</span></a></h2><p>注意：es2015引入了原生的类支持到js中，但是，首先，它们是js现存基于原型的继承模型的语法糖。我们不会在书中涉及es2015类，但是mdn又它们极好的介绍。</p><p>记住，表格中又得模式参考了类的概念。在es5中，js是无类语言，但是类能实用函数模拟。</p><p>想要做到这个的最统一的方法是定义js函数，之后，我们在其中使用new关键字来创建对象。this能够被用来帮助定义对象的属性以及方法，如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token comment">// A car &quot;class&quot;</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span> <span class="token parameter">model</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"> </span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>model <span class="token operator">=</span> model<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&quot;silver&quot;</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token string">&quot;2012&quot;</span><span class="token punctuation">;</span></span>
<span class="line"> </span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getInfo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>model <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>year<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"> </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后，我们可以使用Car构造函数实例化对象，我们像下面这样定义：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> myCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token string">&quot;ford&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"> </span>
<span class="line">myCar<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token string">&quot;2010&quot;</span><span class="token punctuation">;</span></span>
<span class="line"> </span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> myCar<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用js定义类的更多方式，看Stoyan Stefanov的关于它们的有用博客。</p><p>现在，让我们继续查看表格：</p><h2 id="创建型-基于创建对象的概念" tabindex="-1"><a class="header-anchor" href="#创建型-基于创建对象的概念"><span>创建型 基于创建对象的概念</span></a></h2><ul><li>类</li></ul><p>工厂方法 这使得基于接口数据或事件的多个派生类成为一个实例</p><ul><li>对象</li></ul><p>抽象工厂 创建几个相似的类的实例，而不需要详细关注类</p><p>建造者 单独的对象从它的代表中构造，一直创建相同类型的对象</p><p>原型 用来拷贝或者克隆的完整的初始化实例</p><p>单例 只有单个又全局访问点的实例的类</p><h2 id="构造型-基于构建对象块的思想" tabindex="-1"><a class="header-anchor" href="#构造型-基于构建对象块的思想"><span>构造型 基于构建对象块的思想</span></a></h2><ul><li>类</li></ul><p>适配器 匹配不同类的接口，因此，尽管接口不兼容，类还是能够在一起工作</p><ul><li>对象</li></ul><p>桥接 把对象的接口和它的实现分离，这样两者可以独立变化</p><p>组合 简单组合对象的结构，使得整个对象不只是各个部分总和</p><p>装饰器 动态的给对象添加可选处理</p><p>门面 隐藏了整个子系统的复杂度的单个类</p><p>享元 一种细粒度的实例，用于有效共享包含在其他地方的信息</p><p>代理 一个代表真实对象的占位符对象</p><h2 id="行为型-基于对象一起玩耍和工作的方式" tabindex="-1"><a class="header-anchor" href="#行为型-基于对象一起玩耍和工作的方式"><span>行为型 基于对象一起玩耍和工作的方式</span></a></h2><ul><li>类</li></ul><p>解释器 在应用中，包含语言元素用来匹配目标语言的语法的一种方式</p><p>模板方法 在方法中创建算法的外壳，延迟额外的步骤到子类中</p><ul><li>对象</li></ul><p>职责链 对象链之间床底请求来找到处理请求的对象的方法</p><p>命令 封装一个命令请求作为一个启用的对象，日志和/或请求队列，以及给未处理请求提供错误处理</p><p>迭代器 连续的访问集合对象，而不用了解集合的内部工作原理</p><p>中介者 在类之间定义简单的通信来阻止一组类相互显示引用</p><p>备忘录 捕获一个对象的内部状态，以便之后能够恢复它</p><p>观察者 通知许多类改变来确保类之间的统一的方式</p><p>状态 状态改变时，它修改对象的行为</p><p>策略 将算法封装在类中，将选择与实现分离</p><p>访问者 给类添加一个新的操作符，而不会改变类</p>`,43)]))}const c=a(t,[["render",l]]),u=JSON.parse('{"path":"/books/javascript/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB%E8%A1%A8/","title":"","lang":"en-US","frontmatter":{},"git":{"updatedTime":1735558340000,"contributors":[{"name":"jmz","username":"jmz","email":"mingzhuang.ji@ly.com","commits":3,"url":"https://github.com/jmz"},{"name":"Boswell","username":"Boswell","email":"mingzhuang.ji@ly.com","commits":4,"url":"https://github.com/Boswell"},{"name":"mingzhuang.ji","username":"","email":"mingzhuang.ji@ly.com","commits":2}],"changelog":[{"hash":"dbc456edbfbe7a16e99ef11ad04098fbad26fdc4","time":1735558340000,"email":"mingzhuang.ji@ly.com","author":"mingzhuang.ji","message":"chore: 调整结构"},{"hash":"6cd6513af962d39a4becb6d4423104c209684122","time":1702001688000,"email":"mingzhuang.ji@ly.com","author":"mingzhuang.ji","message":"feat: monorepo"},{"hash":"f2337734b6270ac051b908354dd6dccce75439f6","time":1660138466000,"email":"aiyoudqrjmz@163.com","author":"Boswell","message":"chore: 梳理"},{"hash":"40490e61600ecc7dded37e1f242086aa74489f64","time":1653880183000,"email":"aiyoudqrjmz@163.com","author":"Boswell","message":"feat: lerna"},{"hash":"a91ae3f357e5517c1fe59bdcaee35dcb7f620199","time":1627635031000,"email":"mingzhuang.ji@ly.com","author":"Boswell","message":"feat: books目录"},{"hash":"1dde0babb74363f0c17a499d62b693c8b4123c68","time":1617954954000,"email":"mingzhuang.ji@ly.com","author":"Boswell","message":"博客：整理博客"},{"hash":"7ce14b0f4fcf5e4ca3f6628a3107f4414b5d4250","time":1607772279000,"email":"mingzhuang.ji@ly.com","author":"jmz","message":"js"},{"hash":"56e84d6266e8fe9118927ced7bfdd28d68a6749b","time":1607685291000,"email":"mingzhuang.ji@ly.com","author":"jmz","message":"js"},{"hash":"e963307b025faae359395d8e53d1b35c90d73c4a","time":1607647015000,"email":"mingzhuang.ji@ly.com","author":"jmz","message":"js"}]},"filePathRelative":"books/javascript/javascript设计模式/7设计模式分类汇总表/readme.md"}');export{c as comp,u as data};
