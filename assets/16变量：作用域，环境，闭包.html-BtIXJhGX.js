import{_ as s,c as a,b as p,o as e}from"./app-B56A7WC8.js";const t={};function l(c,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h2 id="定义一个变量" tabindex="-1"><a class="header-anchor" href="#定义一个变量"><span>定义一个变量</span></a></h2><p>在javascript中，你通过var声明定义一个变量，在你使用它之前：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> foo<span class="token punctuation">;</span></span>
<span class="line">foo <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// OK, has been declared</span></span>
<span class="line">bar <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// not OK, an undeclared variable</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你还可以组合一个定义和赋值，来立即初始化一个变量。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>一个没有初始化的变量的值为undefined:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> x<span class="token punctuation">;</span></span>
<span class="line">x</span>
<span class="line"><span class="token keyword">undefined</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="背景-静态vs动态" tabindex="-1"><a class="header-anchor" href="#背景-静态vs动态"><span>背景：静态vs动态</span></a></h2><p>你可以从两个角度测试程序的工作原理：</p><ul><li>静态地或者词法地</li></ul><p>检查程序是否存在源代码中，没有运行。给出下面的代码，我们能做出函数g被嵌套在函数f内部的断言：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>形容词词法的和静态的用法相同，因为两者都属于程序的词典（文字，来源）。</p><ul><li>动态地</li></ul><p>你测试当执行程序的时候发生了什么（在运行时中），给出下面的代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们调用f()函数，它会调用g()函数，运行时期间，g一直被f调用，表示一个动态的关系。</p><h2 id="背景-变量作用域" tabindex="-1"><a class="header-anchor" href="#背景-变量作用域"><span>背景：变量作用域</span></a></h2><p>这章剩余部分，你应该理解下面的概念：</p><ul><li>一个变量的作用域</li></ul><p>一个变量的作用域是它能够访问的位置。例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> x<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里x的直接作用域是函数foo().</p><ul><li>词法作用域</li></ul><p>在javascript中的变量是词法地作用域。所以一个程序的静态结构决定一个变量的作用域。（它不会被函数从哪里调用而影响）</p><ul><li>嵌套作用域</li></ul><p>如果作用域被嵌套在一个变量的直接作用域中，之后变量在所有这些作用域中可以被访问：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;arg: &#39;</span> <span class="token operator">+</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// arg: hello</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arg的直接作用域是foo()函数，但是在嵌套作用域bar()函数中也能够被访问。关于嵌套，foo()函数是外面的作用域，以及bar()函数是内部的作用域。</p><ul><li>遮蔽</li></ul><p>如果一个作用域定义一个相同名称的变量作为一个整体，在周围的作用域中，访问外部变量被阻止在内部作用域以及所有嵌套它在内的作用域，改变内部作用域不影响外部变量，内部作用域离开后，在次访问外部作用域：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">&quot;local&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// local</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// global</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>f()函数内部，全局x被本地x遮蔽了。</p><h2 id="函数作用域的变量" tabindex="-1"><a class="header-anchor" href="#函数作用域的变量"><span>函数作用域的变量</span></a></h2><p>大部分主流语言都是块级作用域的： 变量存活在最内部的周围代码块。这里有一个java的例子：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">{</span> <span class="token comment">// block starts</span></span>
<span class="line">        <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token comment">// block ends</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: cannot find symbol</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在前面的代码中，变量foo只能在直接包围它的块内部才能访问到。如果我们尝试在块之后访问它，我们会得到一个编译错误。</p><p>与此相反，javascript的便来给你是函数作用域的：只有函数引入新的作用域；当它进入作用域时，块被忽略。例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">{</span> <span class="token comment">// block starts</span></span>
<span class="line">        <span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token comment">// block ends</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>换句话说，foo在main()可以被访问，不仅时块中。</p><h2 id="被提升的变量定义" tabindex="-1"><a class="header-anchor" href="#被提升的变量定义"><span>被提升的变量定义</span></a></h2><p>javascript提升所有变量的定义，它移动它们到它们直接作用域的开始位置。如果一个变量在定义之前被访问，这个将使得它清楚了解发生了什么：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></span>
<span class="line">    <span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token string">&#39;abc&#39;</span><span class="token punctuation">;</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// abc</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们能看到变量bar在第一行的时候就已经存在了，但是它还没有值，定义已经被提升，但是没有赋值。javascript执行f()函数，就好像，它的代码是：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> bar<span class="token punctuation">;</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></span>
<span class="line">    bar <span class="token operator">=</span> <span class="token string">&#39;abc&#39;</span><span class="token punctuation">;</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// abc</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你定义了一个已经被定义过的变量，什么也不会发生（变量的值没有改变）：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">var</span> x<span class="token punctuation">;</span></span>
<span class="line">x</span>
<span class="line"><span class="token number">123</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每一个函数也被提升了，但是方法稍微不同。完整的函数提升，不仅是被存储在其中的变量的创建。</p><h2 id="通过一个iife引入一个新作用域" tabindex="-1"><a class="header-anchor" href="#通过一个iife引入一个新作用域"><span>通过一个IIFE引入一个新作用域</span></a></h2><p>你典型的引入一个新作用域来限制变量的生存周期。你可能想要做这样的一个例子是，if声明的部分：只有条件成立时，才会执行；并且如果它只使用辅助变量，我们不想它们泄露到周围的作用域：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token operator">...</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// tmp still exists here</span></span>
<span class="line">    <span class="token comment">// =&gt; not what we want</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你想要给then块引入一个新的作用域，你可以定义一个函数，并且立即调用它。这个是块级作用域的模拟变通方法。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// open block</span></span>
<span class="line">            <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token operator">...</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// close block</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个是javascript中的一个普通模式。Ben Alman建议把他称为立即执行函数表达式，（IIFE）, 一般来说，一个IIFE像这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// open IIFE</span></span>
<span class="line">    <span class="token comment">// inside IIFE</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// close IIFE</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里是关于IIFE的一些注意事项：</p><ul><li>它是立即执行的</li></ul><p>函数右大括号后的括号立即调用它。那意味着他的函数体被立即执行。</p><ul><li>它一定是一个表达式</li></ul><p>如果使用关键字function声明开始，解析器期待它是一个函数定义。但是一个函数定义不能被立即调用。因此，我们告诉解析器关键字function是函数表达式的开始，以左括号开始语句。在括号内部，只能是表达式。</p><ul><li>尾部的分号是必须的</li></ul><p>如果你在两个IIFE之间忘记了它，之后，你的代码将不会工作：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token operator">...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// no semicolon</span></span>
<span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token operator">...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码作为函数调用被打断，第一个IIFE是被调用的函数，以及第二个IIFE是参数。</p><ul><li>IIFE变种：前缀操作符</li></ul><p>通过前缀表达式，你还能强迫表达式上下文。例如，通过逻辑非操作符，你能这样做：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token operator">!</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// open IIFE</span></span>
<span class="line">    <span class="token comment">// inside IIFE</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// close IIFE</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者通过void操作符</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">void</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// open IIFE</span></span>
<span class="line">    <span class="token comment">// inside IIFE</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// close IIFE</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用前缀表达式的优点是忘记终止分号不会引起问题。</p><ul><li>IIFE变种：已经在表达式上下文中</li></ul><p>注意，强制给IIFE表达式上下文不必要，如果你是已经在表达式上下文中，之后你不需要圆括号或者前缀操作符，例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> <span class="token function-variable function">File</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// open IIFE</span></span>
<span class="line">    <span class="token keyword">var</span> <span class="token constant">UNTITLED</span> <span class="token operator">=</span> <span class="token string">&#39;Untitled&#39;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">function</span> <span class="token function">File</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token constant">UNTITLED</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> File<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// close IIFE</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在前面的例子中，有两个名字为File的不同变量。一边，有只直接在IIFE内部访问的函数。另一边，有在第一行被定义的变量。它被附上在IIFE中返回的值。</p><ul><li>IIFE变种：带有参数的立即执行环境</li></ul><p>你能使用参数来定义IIFE内部的变量；</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">twice</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>twice<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span>x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个是相似的：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> twice <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>twice<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>IIFE应用程序</li></ul><p>一个IIFE让你能够链接函数的私有数据。之后，你不能定义全局变量，并且能够紧密的将函数和它的状态封装起来。你避免污染全局变量的命名空间。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> <span class="token function-variable function">setValue</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> prevValue<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// define setValue</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!==</span> prevValue<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Changed: &#39;</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            prevValue <span class="token operator">=</span> value<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他IIFE的应用程序在这本数的其他地方被提到：</p><ul><li>避免全局变量；隐藏全局变量；</li><li>创建新鲜环境；避免共享；</li><li>保持全局数据对所有构造函数私有；</li><li>附加全局数据到一个单例对象；</li><li>附加全局数据到一个方法；</li></ul><h2 id="全局变量" tabindex="-1"><a class="header-anchor" href="#全局变量"><span>全局变量</span></a></h2><p>包含所有程序的作用域被称为全局作用域或者程序作用域。这个是你在进入script时的作用域（它是页面的script标签或者它是.js文件）。在全局作用域的内部，你能通过定义一个函数来创建一个嵌套的作用域。在这样的函数内部，你可以再嵌套作用域。每个作用域访问它自己的变量以及围绕它的作用域中的变量。因为全局作用域围绕所有其他作用域，它的变量能够再任何地方被访问。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token comment">// here we are in global scope</span></span>
<span class="line"><span class="token keyword">var</span> globalVariable <span class="token operator">=</span> <span class="token string">&#39;xyz&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> localVariable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">var</span> anotherLocalVariable <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// All variables of surround scopes are accessible</span></span>
<span class="line">        localVariable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">        globalVariable <span class="token operator">=</span> <span class="token string">&#39;abc&#39;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">// here we are again in global scope</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>最佳实践：避免全局变量</li></ul><p>全局变量有两个缺点。第一，依赖全局变量的软件层面是项目的副作用；它们是不健壮的，行为不可预测的，已经不可维护的。</p><p>第二，在页面上的所有javascript共享相同的全局变量：你的代码，内置代码，分词代码，社会媒体按钮，等等。那个意味着命名冲突会变成一个问题。这就是为什么最好隐藏尽可能多的全局变量。例如，不要这样做：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Don’t <span class="token keyword">do</span> <span class="token keyword">this</span> <span class="token operator">--</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token comment">// Global scope</span></span>
<span class="line">    <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token function">generateData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">processData</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">persistData</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量tmp变成了全局的，因为它的定义在全局作用域中被执行。但是它只在本地被使用。因此，我们能使用IIFE来隐藏它在一个嵌套的内部作用域中。</p><ul><li>模块系统导致更少的全局</li></ul><p>感谢的是，模块系统几乎消除了全局变量的问题。因为通过全局作用域模块没有接口，以及因为每一个模块都有自己的模块全局变量。</p><h2 id="全局对象" tabindex="-1"><a class="header-anchor" href="#全局对象"><span>全局对象</span></a></h2><p>ECMAScript规格，使用内不得环境数据结构来存储变量。语言右不寻常得特性，通过对象使得环境用于全局变量访问，所谓得全局变量。一个全局对象通常用于创建，阅读，和改变全局变量。在全局作用域下，this指向它：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"> <span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span></span>
<span class="line"> <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token comment">// read global variable</span></span>
<span class="line"> <span class="token string">&#39;hello&#39;</span></span>
<span class="line"></span>
<span class="line"> <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">&#39;world&#39;</span><span class="token punctuation">;</span> <span class="token comment">// create global variable</span></span>
<span class="line"> bar</span>
<span class="line">     <span class="token string">&#39;world&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意全局变量有原型。如果你想要列出所有它的属性（自身的以及继承的），你需要像列出所有属性键的getAllPropertyNames()这样的函数。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">getAllPropertyNames</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">&#39;AnalyserNode&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Array&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;ArrayBuffer&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Attr&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;Audio&#39;</span><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>javascript创始人Brendan Rich 认为全局对象，是最大遗憾之一。它对性能有负面影响，使得变量作用域的实现更加复杂，以及导致不能模块化代码。</p><ul><li>跨平台注意事项</li></ul><p>浏览器和nodejs有全局变量来引用全局对象。不幸的是，它们是不同的：</p><ul><li><p>浏览器包括window, 被规范化作为DOM的一部分，但不是ECMAScript5的一部分。没一个框架（frame）或者window,都有一个全局对象。</p></li><li><p>Nodejs包含global,它是nodejs特定变量。每个模块有自己的作用域，其中的this指向作用域变量的对象。因此this和global在内部是不同的。</p></li></ul><p>在这两个平台上，this引用全局对象，但是只是在全局作用域中才会。在node.js中，几乎不会出现的案例。如果你想要在跨平台方法中访问global对象。你可以使用例如下面的模式：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">glob</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// glob points to global object</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">&#39;undefined&#39;</span> <span class="token operator">?</span> window <span class="token operator">:</span> global<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从现在开始，我使用window来引用global对象，但是在跨平台代码中，你应该使用前面的模式，用glob来代替。</p><ul><li>window使用案例</li></ul><p>这章描述通过window来访问全局变量的案例。但是一般规则是：尽量避免那样做。</p><ul><li>使用案例： 标记全局变量</li></ul><p>前缀window是代码引用一个全局变量而不是本地变量的视觉提示：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 123</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这个让你的代码变得脆弱。一旦你将foo从全局作用域移动到另一个周围作用域它会停止工作。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// undefined</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，引用foo作为变量更好，而不是作为window的属性。如果你想要让foo是全局还是类似全局变量明确，你能添加例如g_的命名前缀：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">var</span> g_foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>g_foo<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用案例：内置</li></ul><p>我不喜欢通过window引用内置的全局变量。它们的名字众所周知，所以你从全局指针中获取很少。并且前缀window增加了凌乱：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">window<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>  <span class="token comment">// no</span></span>
<span class="line"><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>  <span class="token comment">// yes</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用案例：风格检查器</li></ul><p>当你使用像是JSLint和JSHint这样的风格检查工具时，当你在引用一个没有定义在当前文件中的全局变量时使用window意味着你不会得到错误。但是，工具都提供了告诉它们关于这样的变量以及阻止这样的错误。（在它们的文档中搜索全局变量）。</p><ul><li>使用案例：检查是否存在全局变量</li></ul><p>它不是一个会频繁使用的案例，但是shims和polyfills尤其需要检查全局变量someVariable是否存在。在那个案例中，window帮助：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>someVariable<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是执行这个检查的安全方式。下面的声明，如果someVariable没有被定义会抛出异常：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token comment">// Don’t do this</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>someVariable<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>有两种额外的方式，你可以通过window检查；它们粗略相等，但是更为明确：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>someVariable <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&#39;someVariable&#39;</span> <span class="token keyword">in</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过typeof检查一个变量是否存在是一般方式：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> someVariable <span class="token operator">!==</span> <span class="token string">&#39;undefined&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>使用案例：在全局作用域创建事物</li></ul><p>window让你添加事物到全局作用域中。（即使你在嵌套作用域中），并且它让你做事情如此自信：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>window<span class="token punctuation">.</span>someApiFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    window<span class="token punctuation">.</span>someApiFunction <span class="token operator">=</span> <span class="token operator">...</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般最好通过var添加事物到全局作用域，同时你在全局作用域中。但是，window提供一个有条件地增加的干净方案。</p><h2 id="环境-管理变量" tabindex="-1"><a class="header-anchor" href="#环境-管理变量"><span>环境：管理变量</span></a></h2><p><em>环境是一个高级话题，他是javascript的内部细节，如果你想要深入了解变量如何工作，读这个章节</em></p><p>当程序执行进入它的作用域时，变量产生了。之后它需要存储空间。在javascript中，提供存储空间的数据结构被称为环境。它映射变量的名称到其值。它的结构和javascript的object类型非常相似。环境有时存活在你离开它的作用域之后。因此，它们是存储在堆上，而不是存储在栈上。</p><p>变量有两种方式传递。它们有两个维度，如果你愿意的话：</p><ul><li>动态维度： 调用函数</li></ul><p>每次一个函数被调用，它的参数和变量需要新的存储。它完成之后，存储通常能够被回收。作为一个例子，采取下面的factorial函数的实例。每次递归调用自身好几次，n需要新鲜的存储：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">fac</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">fac</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>词法(静态)维度： 和你的周围作用域保持连接</li></ul><p>无论多久调用一个函数，它总是需要访问到自己的本地变量和周围作用域的变量。例如，下面的函数doNTimes，有一个函数助手doNTimesRec，在它的内部。当doNTimesRec调用自身几次，每次会创建一个新环境。但是，这些调用期间，doNTimesRec还与doNTimes单一环境保持连接。类似于所有函数共享一个单独全局环境。doNTimesRec需要访问action的链接。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">doNTimes</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">function</span> <span class="token function">doNTimesRec</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// (1)</span></span>
<span class="line">            <span class="token function">doNTimesRec</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token function">doNTimesRec</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个维度像下面一样被处理:</p><ul><li>动态维度：执行栈上下文</li></ul><p>每次一个函数被调用，一个新的环境被创建来映射标识符（参数和变量）到值。对于递归的处理，执行上下文-引用环境-在栈中被管理。镜像调用堆栈。</p><ul><li>词法维度：环境链</li></ul><p>为了支持这个维度，一个函数通过内部[[scope]]属性创建记录作用域。当一个函数被调用时，一个环境被创建给被进入的新作用域。环境有一个被叫做outer的字段，它指向外部的作用域的环境，并且通过[[scope]]安装。因此，总是有一个环境链，从当前活跃环境为开始，继续它的外部环境，等等。每个链的最后都是全局环境。（所有初始化调用函数的作用域）。全局环境的outer字段是null。</p><p>为了解析一个标识符，完整的环境链被遍历，从当前活跃环境开始。</p><p>让我们来看一个例子：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token parameter">myParam</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> myVar <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> myFloat<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">var</span> myFloat <span class="token operator">=</span> <span class="token number">1.3</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// Step 1</span></span>
<span class="line"><span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token string">&#39;abc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Step 2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明当前面的代码被执行时发生了什么：</p><ol><li>myFunction和myFloat已经被存储在全局环境中。注意，函数对象，被通过内部属性[[scope]]指向它的作用域的myFunction引用。</li><li>myFunction函数的执行，一个新环境被创建来保存参数和本地变量。它通过outer引用它的outer环境（从myFunction[[scope]]）中被初始化。感谢outer变量，myFunction能访问myFloat.</li></ol><h2 id="闭包-与它出生的作用域保持连接的函数" tabindex="-1"><a class="header-anchor" href="#闭包-与它出生的作用域保持连接的函数"><span>闭包：与它出生的作用域保持连接的函数</span></a></h2><p>如果一个函数离开创建它的作用域，它还与那个作用域的变量保持连接（周围作用域），例如，变量提供给函数跨函数调用之间的保持状态。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">createInc</span><span class="token punctuation">(</span><span class="token parameter">startValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">step</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        startValue <span class="token operator">+=</span> step<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> startValue<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过createInc()函数返回没有丢失对startValue变量的联系，变量提供带有保持跨函数调用的状态的函数。名字来源于一个闭包关闭一个函数自由变量的事实。如果变量没有被定义在函数中，就是自由的。就是说，它来自外部。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token operator">&gt;</span> <span class="token keyword">var</span> inc <span class="token operator">=</span> <span class="token function">createInc</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token operator">&gt;</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token number">6</span></span>
<span class="line"><span class="token operator">&gt;</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token number">8</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个闭包是一个函数加与创建这个函数的作用域的链接。</p><ul><li>通过环境来处理闭包</li></ul><p>一个闭包是执行已经离开它的作用域环境仍然存活的例子。说明闭包如何工作，让我们检查之前与createInc()方法的交互，并且把它分成四个步骤（每个步骤期间，活动执行上下文和他的环境是高亮；如果一个函数活跃，他也会变得高亮）：</p><ol><li>这个步骤在交互之前发生，和在createInc()函数定义执行之后。createInc的入口已经被添加到全局环境，并且指向一个函数对象。</li></ol><p>Execution contexts Lexical environments Functions</p><ol start="2"><li><p>这个步骤发生在调用createInc()函数执行期间。创建createInc的一个新鲜环境，并且推入栈中。它的外部环境是全局环境。（与createInc.[[scope]]相同）。环境保存startValue变量。</p></li><li><p>这一步发生在给inc赋值之后，从createInc函数返回之后，执行上下文指向的环境会从栈中移除。但是环境仍然存在堆里。因为inc.[[scope]]引用它，inc是一个闭包（函数加出生环境）。</p></li><li><p>这一步发生在inc()函数执行期间，一个新的环境被创建，并且一个执行上下文指向已经被推到栈中的环境。它的外部环境是inc的[[scope]]。外部环境指定inc访问startValue.</p></li><li><p>这一步发生在inc()执行之后，不再有引用指向inc的环境（执行上下文，outer字段，或者[[scope]]）。因此它不再被需要了，并且会从堆中被移除。</p></li></ol><ul><li>陷阱：无意间共享环境</li></ul><p>有时，你创建的函数的行为会被当前作用域中的一个变量影响。因为每个函数应该处理当函数被创建时的变量的值。但是由于函数是闭包，函数总是处理变量的当前值。在循环中，这可能会阻止事情正常运转。一个更清晰的案例：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span> i<span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> result<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>f()函数返回带有三个函数的数组。所有函数仍然能访问f的环境，所以可以访问i。事实上，它们共享相同的环境。循环完成之后，环境中的i的值为3。因此，所有的函数返回3。</p><p>这个不是我们想要的。要修复这件事，创建一个使用它的函数之前，我们需要对索引i进行一个快照。换句话说，我们想要包裹没有i值的每一个函数在函数创建的同时。因此，我们采取下面的步骤：</p><ol><li>在返回的数组中给每个函数创建一个新环境。</li><li>存储在那个环境中i的当前值。</li></ol><p>只需要函数创建环境，所以我们使用IIFE来完成第一步：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// step 1: IIFE</span></span>
<span class="line">            <span class="token keyword">var</span> pos <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// step 2: copy</span></span>
<span class="line">            <span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">return</span> pos<span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> result<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这个案例有真实世界的关联，因为当你通过循环给dom元素添加事件处理器时，类似的情况会出现。</p>`,173)]))}const o=s(t,[["render",l]]),u=JSON.parse('{"path":"/books/javascript/%E8%AF%9D%E8%AF%B4javascript/3%E6%B7%B1%E5%85%A5javascript/16%E5%8F%98%E9%87%8F%EF%BC%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E7%8E%AF%E5%A2%83%EF%BC%8C%E9%97%AD%E5%8C%85.html","title":"","lang":"en-US","frontmatter":{},"git":{"updatedTime":1735558340000,"contributors":[{"name":"jmz","username":"jmz","email":"mingzhuang.ji@ly.com","commits":2,"url":"https://github.com/jmz"},{"name":"Boswell","username":"Boswell","email":"mingzhuang.ji@ly.com","commits":4,"url":"https://github.com/Boswell"},{"name":"mingzhuang.ji","username":"","email":"mingzhuang.ji@ly.com","commits":2}],"changelog":[{"hash":"dbc456edbfbe7a16e99ef11ad04098fbad26fdc4","time":1735558340000,"email":"mingzhuang.ji@ly.com","author":"mingzhuang.ji","message":"chore: 调整结构"},{"hash":"6cd6513af962d39a4becb6d4423104c209684122","time":1702001688000,"email":"mingzhuang.ji@ly.com","author":"mingzhuang.ji","message":"feat: monorepo"},{"hash":"f2337734b6270ac051b908354dd6dccce75439f6","time":1660138466000,"email":"aiyoudqrjmz@163.com","author":"Boswell","message":"chore: 梳理"},{"hash":"40490e61600ecc7dded37e1f242086aa74489f64","time":1653880183000,"email":"aiyoudqrjmz@163.com","author":"Boswell","message":"feat: lerna"},{"hash":"a91ae3f357e5517c1fe59bdcaee35dcb7f620199","time":1627635031000,"email":"mingzhuang.ji@ly.com","author":"Boswell","message":"feat: books目录"},{"hash":"1dde0babb74363f0c17a499d62b693c8b4123c68","time":1617954954000,"email":"mingzhuang.ji@ly.com","author":"Boswell","message":"博客：整理博客"},{"hash":"4af7402f3a28d13ed97a4634ddd01ebf0f56c3ba","time":1604142805000,"email":"mingzhuang.ji@ly.com","author":"jmz","message":"javascript:翻译"},{"hash":"52401445a70655ab4516abc9aceace99ca0c41d5","time":1604142805000,"email":"mingzhuang.ji@ly.com","author":"jmz","message":"javascript:翻译"}]},"filePathRelative":"books/javascript/话说javascript/3深入javascript/16变量：作用域，环境，闭包.md"}');export{o as comp,u as data};
