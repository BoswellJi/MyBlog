import{_ as a,c as i,b as n,o as s}from"./app-DUVHEK3E.js";const o={};function p(r,e){return s(),i("div",null,[...e[0]||(e[0]=[n('<h1 id="solid-面向对象设计-5-大原则" tabindex="-1"><a class="header-anchor" href="#solid-面向对象设计-5-大原则"><span>SOLID：面向对象设计 5 大原则</span></a></h1><p>SOLID 是一组用于指导面向对象设计的原则，目标是让代码更容易维护、扩展和测试。</p><hr><h2 id="s-single-responsibility-principle-单一职责原则" tabindex="-1"><a class="header-anchor" href="#s-single-responsibility-principle-单一职责原则"><span>S - Single Responsibility Principle（单一职责原则）</span></a></h2><p>一个类只负责一件事，且只有一个引起它变化的原因。</p><h3 id="反例" tabindex="-1"><a class="header-anchor" href="#反例"><span>反例</span></a></h3><p><code>UserService</code> 同时负责：</p><ul><li>用户注册</li><li>数据库存储</li><li>发邮件通知</li></ul><p>这样会导致：注册规则变、存储方案变、邮件模板变，都会改同一个类。</p><h3 id="改进" tabindex="-1"><a class="header-anchor" href="#改进"><span>改进</span></a></h3><ul><li><code>UserService</code>：只处理用户业务逻辑</li><li><code>UserRepository</code>：只处理数据持久化</li><li><code>EmailService</code>：只处理邮件发送</li></ul><hr><h2 id="o-open-closed-principle-开闭原则" tabindex="-1"><a class="header-anchor" href="#o-open-closed-principle-开闭原则"><span>O - Open/Closed Principle（开闭原则）</span></a></h2><p>对扩展开放，对修改关闭。</p><p>新增功能时，优先通过新增代码来扩展，而不是频繁修改稳定代码。</p><h3 id="反例-1" tabindex="-1"><a class="header-anchor" href="#反例-1"><span>反例</span></a></h3><p>支付逻辑写成：</p><ul><li><code>if (type === &quot;wechat&quot;) ...</code></li><li><code>else if (type === &quot;alipay&quot;) ...</code></li><li><code>else if (type === &quot;bank&quot;) ...</code></li></ul><p>每增加一种支付方式，都要改原有分支。</p><h3 id="改进-1" tabindex="-1"><a class="header-anchor" href="#改进-1"><span>改进</span></a></h3><p>定义统一支付接口 <code>PayStrategy</code>，每种支付方式一个实现类。新增支付方式时只新增实现类，不改原调用逻辑。</p><hr><h2 id="l-liskov-substitution-principle-里氏替换原则" tabindex="-1"><a class="header-anchor" href="#l-liskov-substitution-principle-里氏替换原则"><span>L - Liskov Substitution Principle（里氏替换原则）</span></a></h2><p>子类必须能够替换父类，并且不破坏程序正确性。</p><h3 id="直观理解" tabindex="-1"><a class="header-anchor" href="#直观理解"><span>直观理解</span></a></h3><p>如果函数接收的是“父类型”，传入任何“子类型”都应该正常工作，不应出现行为异常。</p><h3 id="常见违背方式" tabindex="-1"><a class="header-anchor" href="#常见违背方式"><span>常见违背方式</span></a></h3><ul><li>子类缩小父类的输入约束（父类能接收，子类反而报错）</li><li>子类改变父类承诺的行为（比如父类方法保证不抛错，子类却抛错）</li></ul><hr><h2 id="i-interface-segregation-principle-接口隔离原则" tabindex="-1"><a class="header-anchor" href="#i-interface-segregation-principle-接口隔离原则"><span>I - Interface Segregation Principle（接口隔离原则）</span></a></h2><p>客户端不应该被迫依赖它不使用的方法。</p><h3 id="反例-2" tabindex="-1"><a class="header-anchor" href="#反例-2"><span>反例</span></a></h3><p>一个大而全接口：</p><ul><li>打印</li><li>扫描</li><li>传真</li></ul><p>普通打印机实现时也被迫写扫描/传真空实现。</p><h3 id="改进-2" tabindex="-1"><a class="header-anchor" href="#改进-2"><span>改进</span></a></h3><p>拆分为多个小接口：</p><ul><li><code>IPrinter</code></li><li><code>IScanner</code></li><li><code>IFax</code></li></ul><p>设备按需实现，避免“胖接口”。</p><hr><h2 id="d-dependency-inversion-principle-依赖倒置原则" tabindex="-1"><a class="header-anchor" href="#d-dependency-inversion-principle-依赖倒置原则"><span>D - Dependency Inversion Principle（依赖倒置原则）</span></a></h2><p>高层模块不应依赖低层模块，二者都应依赖抽象。</p><h3 id="反例-3" tabindex="-1"><a class="header-anchor" href="#反例-3"><span>反例</span></a></h3><p><code>OrderService</code> 直接 <code>new MysqlOrderRepository()</code>。</p><p>一旦切换 PostgreSQL 或远程 API，业务层要改代码。</p><h3 id="改进-3" tabindex="-1"><a class="header-anchor" href="#改进-3"><span>改进</span></a></h3><p><code>OrderService</code> 依赖 <code>OrderRepository</code> 抽象，具体实现通过构造注入。</p><p>好处：</p><ul><li>可替换实现</li><li>更易单元测试（可注入 Mock）</li><li>业务层与基础设施解耦</li></ul><hr><h2 id="类-class" tabindex="-1"><a class="header-anchor" href="#类-class"><span>类（Class）</span></a></h2><p>类是对象的模板，描述对象的属性和行为。</p><ul><li><strong>属性</strong>：对象的状态（例如 name、age）</li><li><strong>方法</strong>：对象的行为（例如 login、logout）</li></ul><p>类关注“实现细节”，强调封装与复用。</p><hr><h2 id="接口-interface" tabindex="-1"><a class="header-anchor" href="#接口-interface"><span>接口（Interface）</span></a></h2><p>接口定义“能做什么”，不关心“怎么做”。</p><ul><li>约定能力边界</li><li>统一调用方式</li><li>隔离具体实现</li></ul><p>在 TypeScript 中，接口常用于约束对象结构与依赖抽象。</p><hr><h2 id="类与接口的关系" tabindex="-1"><a class="header-anchor" href="#类与接口的关系"><span>类与接口的关系</span></a></h2><ul><li><strong>实现关系（implements）</strong>：类实现接口定义的能力</li><li><strong>依赖关系（depends on）</strong>：类依赖接口而不是具体类</li></ul><p>推荐做法：面向接口编程，而不是面向具体实现编程。</p><hr><h2 id="类之间的关系" tabindex="-1"><a class="header-anchor" href="#类之间的关系"><span>类之间的关系</span></a></h2><h3 id="_1-关联-association" tabindex="-1"><a class="header-anchor" href="#_1-关联-association"><span>1) 关联（Association）</span></a></h3><p>一个类“知道”另一个类，通常是成员变量引用。</p><p>例子：<code>Order</code> 持有 <code>User</code>。</p><h3 id="_2-聚合-aggregation" tabindex="-1"><a class="header-anchor" href="#_2-聚合-aggregation"><span>2) 聚合（Aggregation）</span></a></h3><p>整体与部分关系，但部分可独立存在。</p><p>例子：<code>Team</code> 和 <code>Player</code>，球员离开队伍仍可存在。</p><h3 id="_3-组合-composition" tabindex="-1"><a class="header-anchor" href="#_3-组合-composition"><span>3) 组合（Composition）</span></a></h3><p>整体与部分强依赖，部分生命周期依赖整体。</p><p>例子：<code>House</code> 和 <code>Room</code>，房子销毁，房间也随之消失。</p><h3 id="_4-继承-inheritance" tabindex="-1"><a class="header-anchor" href="#_4-继承-inheritance"><span>4) 继承（Inheritance）</span></a></h3><p>子类复用父类能力，表示 is-a 关系。</p><p>例子：<code>Cat</code> 继承 <code>Animal</code>。</p><h3 id="_5-依赖-dependency" tabindex="-1"><a class="header-anchor" href="#_5-依赖-dependency"><span>5) 依赖（Dependency）</span></a></h3><p>一个类在方法参数或局部变量中临时使用另一个类。</p><p>例子：<code>ReportService</code> 在 <code>generate()</code> 中使用 <code>PdfGenerator</code>。</p><hr><h2 id="实践建议" tabindex="-1"><a class="header-anchor" href="#实践建议"><span>实践建议</span></a></h2><ol><li>先保证单一职责，再谈抽象。</li><li>优先组合，谨慎继承。</li><li>业务层依赖接口，基础设施层实现接口。</li><li>接口保持小而专，避免“大而全”。</li><li>设计时先考虑“未来怎么扩展”，再落实现有需求。</li></ol><hr><h2 id="一句话总结" tabindex="-1"><a class="header-anchor" href="#一句话总结"><span>一句话总结</span></a></h2><p>SOLID 的核心不是“为了设计而设计”，而是通过合理抽象和解耦，让系统在需求变化时仍然稳定、可扩展、可测试。</p>',86)])])}const l=a(o,[["render",p]]),h=JSON.parse('{"path":"/ts/oop/oop%E7%9A%845%E5%A4%A7%E5%8E%9F%E5%88%99.html","title":"SOLID：面向对象设计 5 大原则","lang":"en-US","frontmatter":{},"git":{"updatedTime":1764567601000,"contributors":[{"name":"mingzhuang.ji","username":"","email":"mingzhuang.ji@ly.com","commits":4}],"changelog":[{"hash":"43c85e394c6fea4870c2315f0164492a987455dc","time":1764567601000,"email":"mingzhuang.ji@ly.com","author":"mingzhuang.ji","message":"chore: 调整架构"},{"hash":"70b4f691e1c73f139c2f924714d83421203012ba","time":1718759308000,"email":"mingzhuang.ji@ly.com","author":"mingzhuang.ji","message":"chore(blog): 重命名"},{"hash":"6cd6513af962d39a4becb6d4423104c209684122","time":1702001688000,"email":"mingzhuang.ji@ly.com","author":"mingzhuang.ji","message":"feat: monorepo"},{"hash":"1b6616bc4ed83219ad2d13851590e52b2599d958","time":1688730616000,"email":"mingzhuang.ji@ly.com","author":"mingzhuang.ji","message":"feat: [前端] oop"}]},"filePathRelative":"ts/oop/oop的5大原则.md"}');export{l as comp,h as data};
