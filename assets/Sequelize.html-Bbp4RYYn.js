import{_ as a,c as i,b as l,o as d}from"./app-DUVHEK3E.js";const c={};function o(n,e){return d(),i("div",null,[...e[0]||(e[0]=[l('<h1 id="sequelize-orm" tabindex="-1"><a class="header-anchor" href="#sequelize-orm"><span>Sequelize ORM</span></a></h1><h2 id="_1-orm-是什么-为什么用-sequelize" tabindex="-1"><a class="header-anchor" href="#_1-orm-是什么-为什么用-sequelize"><span>1. ORM 是什么，为什么用 Sequelize</span></a></h2><ul><li>ORM 定义：用代码对象表达表结构与数据访问，让业务层少写重复 SQL</li><li>Sequelize 优势： <ul><li>多数据库方言（MySQL/PostgreSQL/SQLite/MSSQL）</li><li>关联关系、事务、迁移（Migration）能力完整</li><li>生态成熟，上手成本低</li></ul></li><li>什么时候不适合： <ul><li>极致性能/极复杂 SQL：建议原生 SQL 或按需混用</li><li>强类型优先、偏生成式开发：可对比 Prisma（作为选型讨论）</li></ul></li></ul><hr><h2 id="_2-核心概念速览" tabindex="-1"><a class="header-anchor" href="#_2-核心概念速览"><span>2. 核心概念速览</span></a></h2><h3 id="_2-1-关键对象" tabindex="-1"><a class="header-anchor" href="#_2-1-关键对象"><span>2.1 关键对象</span></a></h3><ul><li><code>Sequelize</code>：连接配置、连接池、日志、方言</li><li><code>Model</code>：表结构映射 + 查询能力（静态方法）</li><li>Instance：表中一行数据的对象（实例方法、<code>toJSON()</code>）</li></ul><h3 id="_2-2-常用配置" tabindex="-1"><a class="header-anchor" href="#_2-2-常用配置"><span>2.2 常用配置</span></a></h3><ul><li><code>logging</code>：开发环境输出 SQL，生产可切换为结构化日志/慢查询</li><li><code>pool</code>：连接池参数</li><li><code>timezone</code> / <code>dialectOptions</code>：时区与驱动参数</li><li>模型层：<code>timestamps</code>、<code>paranoid</code>、<code>underscored</code>、<code>freezeTableName</code></li></ul><h3 id="_2-3-常用类型与陷阱" tabindex="-1"><a class="header-anchor" href="#_2-3-常用类型与陷阱"><span>2.3 常用类型与陷阱</span></a></h3><ul><li><code>DataTypes.DATE</code>：时区、序列化</li><li><code>DataTypes.DECIMAL</code>：金额建议 DECIMAL，JS 侧注意字符串/精度</li><li><code>DataTypes.JSON</code>：不同数据库支持差异</li></ul><hr><h2 id="_3-从-0-到-1-最小可运行示例" tabindex="-1"><a class="header-anchor" href="#_3-从-0-到-1-最小可运行示例"><span>3. 从 0 到 1：最小可运行示例</span></a></h2><h3 id="_3-1-初始化连接" tabindex="-1"><a class="header-anchor" href="#_3-1-初始化连接"><span>3.1 初始化连接</span></a></h3><ul><li>环境变量：<code>DB_HOST/DB_PORT/DB_USER/DB_PASS/DB_NAME</code></li><li>连接池：最大连接数、空闲回收、超时</li><li>日志策略：dev 打印 SQL，prod 记录慢查询</li></ul><h3 id="_3-2-定义模型-以-user-为例" tabindex="-1"><a class="header-anchor" href="#_3-2-定义模型-以-user-为例"><span>3.2 定义模型（以 User 为例）</span></a></h3><ul><li>字段：<code>id</code>、<code>email</code>（唯一）、<code>nickname</code>、<code>status</code>、<code>createdAt/updatedAt</code></li><li>约束：唯一键、非空、默认值</li><li>索引：按查询条件建立（如 <code>email</code>）</li></ul><h3 id="_3-3-基础-crud" tabindex="-1"><a class="header-anchor" href="#_3-3-基础-crud"><span>3.3 基础 CRUD</span></a></h3><ul><li><code>create</code>：创建记录</li><li><code>findOne</code>/<code>findByPk</code>：单条</li><li><code>findAll</code>：列表</li><li><code>update</code>：更新（注意返回值）</li><li><code>destroy</code>：删除（结合 <code>paranoid</code> 说明软删）</li><li>字段选择：<code>attributes</code>（只取需要字段）</li><li>返回形态：Instance vs <code>raw: true</code>（讲清楚序列化差异）</li></ul><hr><h2 id="_4-查询能力进阶" tabindex="-1"><a class="header-anchor" href="#_4-查询能力进阶"><span>4. 查询能力进阶</span></a></h2><h3 id="_4-1-条件查询与运算符" tabindex="-1"><a class="header-anchor" href="#_4-1-条件查询与运算符"><span>4.1 条件查询与运算符</span></a></h3><ul><li><code>where</code> 基础</li><li><code>Op</code>：<code>Op.like</code>、<code>Op.in</code>、<code>Op.or</code>、<code>Op.between</code>、<code>Op.gt/gte/lt/lte</code></li><li>模糊搜索与索引：<code>LIKE &#39;%xxx%&#39;</code> 的性能问题（引出搜索方案或前缀匹配）</li></ul><h3 id="_4-2-分页" tabindex="-1"><a class="header-anchor" href="#_4-2-分页"><span>4.2 分页</span></a></h3><ul><li><code>limit/offset</code>：简单易用，但 offset 大会慢</li><li>游标分页（概念讲解即可）：用 <code>id</code> 或时间字段做 cursor</li></ul><h3 id="_4-3-排序、聚合与分组" tabindex="-1"><a class="header-anchor" href="#_4-3-排序、聚合与分组"><span>4.3 排序、聚合与分组</span></a></h3><ul><li><code>order</code>：多字段排序</li><li><code>group</code> + <code>fn/col</code>：聚合统计</li><li>谨慎使用 <code>literal</code>（强调 SQL 注入风险与可维护性）</li></ul><h3 id="_4-4-原生-sql-混用策略" tabindex="-1"><a class="header-anchor" href="#_4-4-原生-sql-混用策略"><span>4.4 原生 SQL（混用策略）</span></a></h3><ul><li><code>sequelize.query()</code> 使用场景：复杂报表/窗口函数/方言特性</li><li>安全绑定：<code>replacements</code> / <code>bind</code>，避免字符串拼接</li></ul><hr><h2 id="_5-关联关系" tabindex="-1"><a class="header-anchor" href="#_5-关联关系"><span>5. 关联关系</span></a></h2><h3 id="_5-1-四类关联" tabindex="-1"><a class="header-anchor" href="#_5-1-四类关联"><span>5.1 四类关联</span></a></h3><ul><li>一对一：<code>hasOne</code> / <code>belongsTo</code></li><li>一对多：<code>hasMany</code> / <code>belongsTo</code></li><li>多对多：<code>belongsToMany</code>（through 中间表）</li></ul><h3 id="_5-2-关联定义关键参数" tabindex="-1"><a class="header-anchor" href="#_5-2-关联定义关键参数"><span>5.2 关联定义关键参数</span></a></h3><ul><li><code>foreignKey</code>：外键字段名</li><li><code>as</code>：别名（避免同表多关联冲突）</li><li><code>through</code>：中间表配置</li><li><code>constraints</code>：是否启用外键约束</li></ul><h3 id="_5-3-预加载-include-与-n-1" tabindex="-1"><a class="header-anchor" href="#_5-3-预加载-include-与-n-1"><span>5.3 预加载 include 与 N+1</span></a></h3><ul><li><code>include</code>：一次查询拉取关联数据</li><li><code>required: true</code>：inner join 行为</li><li>嵌套 include：多层关联（谨慎，容易产生复杂 SQL）</li><li>N+1 问题：什么是、怎么发现、怎么通过 include/批量查询解决</li></ul><hr><h2 id="_6-事务与一致性" tabindex="-1"><a class="header-anchor" href="#_6-事务与一致性"><span>6. 事务与一致性</span></a></h2><h3 id="_6-1-事务的正确姿势" tabindex="-1"><a class="header-anchor" href="#_6-1-事务的正确姿势"><span>6.1 事务的正确姿势</span></a></h3><ul><li><code>sequelize.transaction(async (t) =&gt; { ... })</code></li><li>所有查询都要传 <code>transaction: t</code>（最常见坑）</li></ul><h3 id="_6-2-并发控制" tabindex="-1"><a class="header-anchor" href="#_6-2-并发控制"><span>6.2 并发控制</span></a></h3><ul><li>悲观锁：<code>LOCK.UPDATE</code>（适合库存/余额等强一致）</li><li>乐观锁：版本号/更新时间校验（适合冲突概率较低场景）</li><li>隔离级别：按业务需求点到即可</li></ul><hr><h2 id="_7-schema-管理-migration-seeder" tabindex="-1"><a class="header-anchor" href="#_7-schema-管理-migration-seeder"><span>7. Schema 管理：Migration &amp; Seeder</span></a></h2><ul><li>为什么生产不要依赖 <code>sync({ alter: true })</code>：不可控、风险大</li><li>Migration：<code>up/down</code>，新增字段、索引、约束</li><li>Seeder：初始化数据/演示数据</li></ul><hr><h2 id="_8-工程化最佳实践" tabindex="-1"><a class="header-anchor" href="#_8-工程化最佳实践"><span>8. 工程化最佳实践</span></a></h2><h3 id="_8-1-分层与可维护性" tabindex="-1"><a class="header-anchor" href="#_8-1-分层与可维护性"><span>8.1 分层与可维护性</span></a></h3><ul><li>Model 只放结构与基础关系</li><li>业务访问建议抽 <code>repository/service</code>：聚合查询、事务边界、复用</li></ul><h3 id="_8-2-错误处理" tabindex="-1"><a class="header-anchor" href="#_8-2-错误处理"><span>8.2 错误处理</span></a></h3><ul><li>唯一键冲突、外键约束、not null 等错误映射成业务错误码</li><li>统一处理：避免把数据库错误直接透传给前端</li></ul><h3 id="_8-3-日志与可观测性" tabindex="-1"><a class="header-anchor" href="#_8-3-日志与可观测性"><span>8.3 日志与可观测性</span></a></h3><ul><li>记录慢查询与关键 SQL</li><li>链路追踪/错误上报（如 Sentry/APM）：把 SQL/耗时放进上下文（注意脱敏）</li></ul><h3 id="_8-4-安全" tabindex="-1"><a class="header-anchor" href="#_8-4-安全"><span>8.4 安全</span></a></h3><ul><li>参数化查询，避免 <code>literal</code> 拼接</li><li>敏感字段脱敏（手机号/邮箱/身份证等）</li></ul><h3 id="_8-5-typescript-如果团队使用-ts" tabindex="-1"><a class="header-anchor" href="#_8-5-typescript-如果团队使用-ts"><span>8.5 TypeScript（如果团队使用 TS）</span></a></h3><ul><li>模型类型推导：<code>InferAttributes</code> / <code>InferCreationAttributes</code></li><li>DTO/Entity 分离：避免把 ORM Instance 当作 API 返回类型</li></ul><hr><h2 id="_10-结尾与-q-a" tabindex="-1"><a class="header-anchor" href="#_10-结尾与-q-a"><span>10. 结尾与 Q&amp;A</span></a></h2><ul><li>总结：Sequelize 解决“高效组织数据访问”，但不替代数据库设计与性能优化</li><li>关联 include 避免 N+1</li><li>事务边界清晰、传递 <code>transaction</code></li><li>生产用 migration 管理 schema</li><li>关键查询加索引、监控慢查询</li></ul><hr>',62)])])}const r=a(c,[["render",o]]),h=JSON.parse('{"path":"/database/Sequelize.html","title":"Sequelize ORM","lang":"en-US","frontmatter":{},"git":{"updatedTime":1770340221000,"contributors":[{"name":"mingzhuang.ji","username":"","email":"mingzhuang.ji@ly.com","commits":1}],"changelog":[{"hash":"e9c0ad81a91d6ed9b5ba57e3fffeb0242edd22b1","time":1770340221000,"email":"mingzhuang.ji@ly.com","author":"mingzhuang.ji","message":"feat: 基于nuxt的c端脚手架文档"}]},"filePathRelative":"database/Sequelize.md"}');export{r as comp,h as data};
